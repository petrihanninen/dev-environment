'use strict';
var tokenizer_1 = require('./tokenizer');
exports.tokenizer = tokenizer_1.default;
function makeMixinParameters(text, offset) {
    var variables = [];
    if (text === '()') {
        return variables;
    }
    text = text.slice(1, text.length - 1);
    var params = text.split(/([,;]\s*)(?=@)/);
    offset += 1;
    for (var i = 0; i < params.length; i = i + 2) {
        var token = params[i];
        var stat = token.match(/([\n\t\r\s]*)(@[\w-]+)(?:\s*:\s*(.*))?/);
        offset += stat[1].length || 0;
        variables.push({
            name: stat[2],
            value: stat[3] ? stat[3].trim() : null,
            offset: offset
        });
        offset += token.trim().length + (params[i + 1] ? params[i + 1].length : 0);
    }
    return variables;
}
function parseSymbols(text) {
    var tokens = tokenizer_1.default(text);
    var variables = [];
    var mixins = [];
    var imports = [];
    var token;
    var pos = 0;
    var offset = 0;
    var length = tokens.length;
    var reImportStat = /(?:\(([\w-,\s]+)\))?\s['"](.*)['"]/;
    var reImportDynamic = /[@{}\*]/;
    while (pos < length) {
        token = tokens[pos];
        if (token[0] === 'at-word' && token[1] === '@import') {
            pos++;
            var str = '';
            while (pos < length) {
                token = tokens[pos];
                if (token[0] === ';') {
                    break;
                }
                str += token[1];
                pos++;
            }
            var stat = str.match(reImportStat);
            if (!stat) {
                continue;
            }
            var modes = stat[1] ? stat[1].split(/,\s*/) : [];
            imports.push({
                filepath: stat[2],
                modes: modes,
                dynamic: reImportDynamic.test(stat[2]),
                css: /\.css$/.test(stat[2]) || modes.indexOf('css') !== -1
            });
        }
        else if (token[0] === 'at-word' && token[1].indexOf(':') !== -1 && !token[1].endsWith(':')) {
            var colonIndex = token[1].indexOf(':') + 1;
            var value = token[1].substr(colonIndex);
            token[1] = token[1].substring(0, colonIndex);
            tokens.splice(pos + 1, 0, ['string', value]);
            pos--;
        }
        else if (token[0] === 'at-word' && token[1].endsWith(':')) {
            offset = token[2];
            pos++;
            var name_1 = token[1].slice(0, -1);
            var value = '';
            while (pos < length && tokens[pos][0] !== ';') {
                token = tokens[pos];
                if (token[0] === '{') {
                    var ruleset = 1;
                    value += '{';
                    pos++;
                    while (pos < length) {
                        token = tokens[pos];
                        if (token[0] === ';' && ruleset === 0) {
                            break;
                        }
                        else if (token[0] === '{') {
                            ruleset++;
                        }
                        else if (token[0] === '}') {
                            ruleset--;
                            if (ruleset === 0) {
                                value += '}';
                                break;
                            }
                        }
                        value += token[1].replace(/\t/g, '');
                        pos++;
                    }
                }
                else if (token[0] === 'word' || token[0] === 'at-word' || token[0] === 'string' || token[0] === 'space') {
                    value += token[1];
                }
                pos++;
            }
            variables.push({
                name: name_1,
                value: value.trim(),
                offset: offset
            });
        }
        else if (token[0] === 'word' && (token[1].startsWith('.') || token[1].startsWith('#'))) {
            offset = token[2];
            var name_2 = '';
            while (pos < length) {
                token = tokens[pos];
                if (token[0] === ':' || token[0] === 'brackets' || token[0] === '(' || token[0] === '{') {
                    break;
                }
                name_2 += token[1];
                pos++;
            }
            var paramsOffset = offset;
            var params = '';
            if (token[0] === 'brackets') {
                paramsOffset = token[2];
                params = token[1];
            }
            else if (token[0] === '(') {
                paramsOffset = token[2];
                pos++;
                while (pos < length) {
                    token = tokens[pos];
                    if (token[0] === ')') {
                        break;
                    }
                    params += token[1];
                    pos++;
                }
                params = "(" + params + ")";
            }
            var c = 0;
            var next = pos;
            while (next < length) {
                token = tokens[next];
                if (token[0] === '{') {
                    break;
                }
                else if (token[0] === ';') {
                    c = 3;
                    break;
                }
                else if (token[0] !== 'word' && token[0] !== 'space' && token[0] !== 'brackets') {
                    c++;
                }
                next++;
            }
            if (c > 2 || next === length) {
                pos++;
                continue;
            }
            if (name_2 && params) {
                mixins.push({
                    name: name_2.trim(),
                    parameters: makeMixinParameters(params, paramsOffset),
                    offset: offset
                });
            }
            else {
                pos--;
            }
        }
        else if (token[0] === '{') {
            var ruleset = 1;
            pos++;
            while (pos < length) {
                token = tokens[pos];
                if (ruleset === 0) {
                    break;
                }
                else if (token[0] === '{') {
                    ruleset++;
                }
                else if (token[0] === '}') {
                    ruleset--;
                }
                pos++;
            }
        }
        pos++;
    }
    return {
        variables: variables,
        mixins: mixins,
        imports: imports
    };
}
exports.parseSymbols = parseSymbols;
